/*
	Example of use of the FFT libray on a "1284 Narrow" board
  to compute the frequency spectrum over 1024 frequency bands
  of a 440 Hz signal (amplitude near 5V), generated by a 
  signal generator and connected through a 1 KOhm resistor to A0.

   It uses 51% of the 16 KB of RAM of the Atmega1284

  Based on https://github.com/kosme/arduinoFFT
  Example adapated by Thierry Guennou / Pandauino.com
  
    ----------------------------
    
  Copyright (C) 2014 Enrique Condes
  Copyright (C) 2020 Bim Overbohm (header-only, template, speed improvements)

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "arduinoFFT.h"

// ****************************************************************************************************************
// DECLARATIONS

#define SCL_INDEX 0x00
#define SCL_TIME 0x01
#define SCL_FREQUENCY 0x02
#define SCL_PLOT 0x03
 
const byte adcPin = A0;                      // A0
const uint16_t samples = 1024;              // This value MUST ALWAYS be a power of 2
const uint16_t samplingFrequency = 8000;    // Will affect timer max value in timer_setup() SYSCLOCK/8/samplingFrequency should be a integer

/*
These are the input and output vectors
Input vectors receive computed results from FFT
*/
volatile int resultNumber;
float vReal[samples];
float vImag[samples];

// ****************************************************************************************************************
// INSTANTIATIONS

/* Create FFT object */
ArduinoFFT<float> FFT = ArduinoFFT<float>(vReal, vImag, samples, samplingFrequency);


// ****************************************************************************************************************
// INTERRUPTS
// Interrupt Service Routine (ISR) for TC1 Compare Match 1
void TC1_Handler() {
  // Your TC3 ISR code here
}

// Interrupt Service Routine (ISR) for ADC Result Ready
void ADC_Handler() {
  vReal[resultNumber++] = REG_ADC_RESULT; // Read the ADC result from the register

  if (resultNumber == samples) {
    REG_ADC_CTRLA &= ~ADC_CTRLA_ENABLE; // Turn off ADC
    NVIC_DisableIRQ(ADC_IRQn);          // Disable ADC interrupt
  }
}


// ****************************************************************************************************************
// FUNCTIONS

//this function gets called by the interrupt at <sampleRate>Hertz
void TC5_Handler (void) {
  //YOUR CODE HERE 
  if(state == true) {
    digitalWrite(LED_PIN,HIGH);
  } else {
    digitalWrite(LED_PIN,LOW);
  }
  state = !state;
  // END OF YOUR CODE
  TC5->COUNT16.INTFLAG.bit.MC0 = 1; //Writing a 1 to INTFLAG.bit.MC0 clears the interrupt so that it will run again
}

/* 
 *  TIMER SPECIFIC FUNCTIONS FOLLOW
 *  you shouldn't change these unless you know what you're doing
 */

//Configures the TC to generate output events at the sample frequency.
//Configures the TC in Frequency Generation mode, with an event output once
//each time the audio sample frequency period expires.
 void tcConfigure(int sampleRate)
{
 // select the generic clock generator used as source to the generic clock multiplexer
 GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TC4_TC5)) ;
 while (GCLK->STATUS.bit.SYNCBUSY);

 tcReset(); //reset TC5

 // Set Timer counter 5 Mode to 16 bits, it will become a 16bit counter ('mode1' in the datasheet)
 TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;
 // Set TC5 waveform generation mode to 'match frequency'
 TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;
 //set prescaler
 //the clock normally counts at the GCLK_TC frequency, but we can set it to divide that frequency to slow it down
 //you can use different prescaler divisons here like TC_CTRLA_PRESCALER_DIV1 to get a different range
 TC5->COUNT16.CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1024 | TC_CTRLA_ENABLE; //it will divide GCLK_TC frequency by 1024
 //set the compare-capture register. 
 //The counter will count up to this value (it's a 16bit counter so we use uint16_t)
 //this is how we fine-tune the frequency, make it count to a lower or higher value
 //system clock should be 1MHz (8MHz/8) at Reset by default
 TC5->COUNT16.CC[0].reg = (uint16_t) (SystemCoreClock / sampleRate);
 while (tcIsSyncing());
 
 // Configure interrupt request
 NVIC_DisableIRQ(TC5_IRQn);
 NVIC_ClearPendingIRQ(TC5_IRQn);
 NVIC_SetPriority(TC5_IRQn, 0);
 NVIC_EnableIRQ(TC5_IRQn);

 // Enable the TC5 interrupt request
 TC5->COUNT16.INTENSET.bit.MC0 = 1;
 while (tcIsSyncing()); //wait until TC5 is done syncing 
} 

//Function that is used to check if TC5 is done syncing
//returns true when it is done syncing
bool tcIsSyncing()
{
  return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
}

//This function enables TC5 and waits for it to be ready
void tcStartCounter()
{
  TC5->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE; //set the CTRLA register
  while (tcIsSyncing()); //wait until snyc'd
}

//Reset TC5 
void tcReset()
{
  TC5->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;
  while (tcIsSyncing());
  while (TC5->COUNT16.CTRLA.bit.SWRST);
}

//disable TC5
void tcDisable()
{
  TC5->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
  while (tcIsSyncing());
}


void timer_setup(int sampleRate) {

  tcConfigure(sampleRate); //configure the timer to run at <sampleRate>Hertz
  tcStartCounter();


//   // Set up Timer/Counter 1 (TC1) for Compare Match B interrupt

//   // Disable TC4 while we make changes to its configuration
//   TC4->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
//   while(TC4->COUNT16.STATUS.bit.SYNCBUSY);

//   // (30.6.2.2) The TC is reset by writing a one to the Software Reset bit in the Control A register (CTRLA.SWRST)
//   TC4->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
//   while(TC4->COUNT16.STATUS.bit.SYNCBUSY);

//   // Set TC4 to 16-bit mode
//   TC4->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16 |   // Set TC1 to 16-bit mode
//                             TC_CTRLA_WAVEGEN_MFRQ |  // Set TC1 to generate a match frequency waveform
//                     TC_CTRLA_PRESCALER_DIV8; // Set prescaler to 8

//   REG_TC1_CTRLBSET = TC_CTRLBSET_ONESHOT |  // Enable one-shot operation
//                     TC_CTRLBSET_DIR;         // Set counter direction to count down

//   REG_TC1_WAVE = TC_WAVE_WAVEGEN_MFRQ;      // Set waveform generation mode to match frequency

//   uint16_t match_value = F_CPU / 8 / samplingFrequency - 1;
//   REG_TC1_CC[1] = match_value;              // Set the match value for the interrupt

//   REG_TC1_INTENSET = TC_INTENSET_MC1;        // Enable interrupt on compare match 1

//   // Enable TC1
//   REG_TC1_CTRLA |= TC_CTRLA_ENABLE;
//   while (TC1->COUNT16.STATUS.bit.SYNCBUSY);
// }

void adc_setup() {
  // Set up ADC

  /* Enable the APB clock for the ADC. */
  PM->APBCMASK.reg |= PM_APBCMASK_ADC;
  
  /* Enable GCLK1 for the ADC */
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_CLKEN |
                      GCLK_CLKCTRL_GEN_GCLK1 |
                      GCLK_CLKCTRL_ID_ADC;

  /* Wait for bus synchronization. */
  while (GCLK->STATUS.bit.SYNCBUSY)

    

  REG_ADC_CTRLA = ADC_CTRLA_SWRST;          // Reset ADC
  while (ADC->STATUS.bit.SYNCBUSY);

  REG_ADC_REFCTRL = ADC_REFCTRL_REFSEL_INTVCC1 | // Set reference voltage to INTVCC1 (3.3V)
                    ADC_REFCTRL_REFCOMP;

  REG_ADC_AVGCTRL = ADC_AVGCTRL_SAMPLENUM_1;  // Set number of samples to average (if desired)

  REG_ADC_CTRLB = ADC_CTRLB_PRESCALER_DIV16 | // Set prescaler to 16
                  ADC_CTRLB_RESSEL_10BIT;     // Set resolution to 10 bits

  REG_ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_PIN0; // Set input to A0 (change as needed)

  REG_ADC_EVCTRL = ADC_EVCTRL_STARTEI |        // Enable start event input
                   ADC_EVCTRL_TIMER_EVT_CMP1; // Timer event as the event action for Compare Match 1

  REG_ADC_INTENSET = ADC_INTENSET_RESRDY;      // Enable result ready interrupt

  REG_ADC_CTRLA |= ADC_CTRLA_ENABLE;          // Enable ADC
  while (ADC->STATUS.bit.SYNCBUSY);
}


void zeroI() {
   for (uint16_t i = 0; i < samples; i++)
  {
    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows
  } 
}

void PrintVector(float *vData, uint16_t bufferSize, uint8_t scaleType)
{
  for (uint16_t i = 0; i < bufferSize; i++)
  {
    float abscissa;
    /* Print abscissa value */
    switch (scaleType)
    {
      case SCL_INDEX:
        abscissa = (i * 1.0);
  break;
      case SCL_TIME:
        abscissa = ((i * 1.0) / samplingFrequency);
  break;
      case SCL_FREQUENCY:
        abscissa = ((i * 1.0 * samplingFrequency) / samples);
  break;
    }
    Serial.print(abscissa, 6);
    if(scaleType==SCL_FREQUENCY)
      Serial.print("Hz");
    Serial.print(" ");
    Serial.println(vData[i], 4);
  }
  Serial.println();
}


// ****************************************************************************************************************
// SETUP

void setup()
{
  Serial.begin(115200);
  while(!Serial);
  Serial.println("Ready");

  zeroI(); // clears imaginary data
  timer_setup(samplingFrequency);
  adc_setup();
  
}

void loop()
{
  // waits until the array is full
  while (resultNumber < samples){ }

  /* Print the raw sampled data */
  //  Serial.println("Data:");
  //  PrintVector(vReal, samples, SCL_TIME);
  
  FFT.dcRemoval(); 
  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);	// Weigh data
  FFT.compute(FFTDirection::Forward); // Compute FFT
  FFT.complexToMagnitude(); // Compute magnitudes 
  // printing the spectrum and the fundamental frequency f0
  PrintVector(vReal, (samples >> 1), SCL_FREQUENCY);
  float x = FFT.majorPeak();
  Serial.print("f0=");
  Serial.print(x, 6);
  Serial.println("Hz");

  resultNumber = 0; 

// ADC could be started again
/*  delay(1000);
  zeroI();
  adc_setup();
*/
 
}
